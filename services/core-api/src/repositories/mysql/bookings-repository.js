/**
 * @file bookings-repository.js
 * @description
 * Repository functions for interacting with the `bookings` and `booking_items`
 * tables in MySQL for the Kayak-like travel platform.
 *
 * Responsibilities:
 * - Provide low-level CRUD helpers for booking headers and line items.
 * - Hide raw SQL strings and column names from higher layers (services/controllers).
 * - Map between database row shapes (snake_case) and domain objects (camelCase).
 * - Accept an optional transactional connection so callers can participate in
 *   multi-step MySQL transactions.
 *
 * Design notes:
 * - This module does **not** open or manage MySQL connections itself. Callers
 *   should obtain a transactional connection via `withMysqlTransaction` from
 *   `src/db/mysql.js` or use the default pool via `mysqlQuery`.
 * - All functions accept an optional `connection` argument. When omitted,
 *   the shared pool is used.
 * - IDs (UUIDs) are expected to be generated by higher layers; the repository
 *   never generates identifiers on its own.
 */



import { mysqlQuery } from "../../db/mysql.js";

/**
 * @typedef {("PENDING"|"CONFIRMED"|"CANCELED"|"FAILED")} BookingStatus
 */

/**
 * @typedef {Object} BookingInsertParams
 * @property {string} id
 * @property {string} userId
 * @property {string} bookingReference
 * @property {BookingStatus} status
 * @property {number} totalAmount
 * @property {string} currency
 * @property {string | null} [startDate]    ISO `YYYY-MM-DD` or null
 * @property {string | null} [endDate]      ISO `YYYY-MM-DD` or null
 * @property {string | null} [notes]
 */

/**
 * @typedef {Object} BookingRecord
 * @property {string} id
 * @property {string} userId
 * @property {string} bookingReference
 * @property {BookingStatus} status
 * @property {number} totalAmount
 * @property {string} currency
 * @property {string | null} startDate
 * @property {string | null} endDate
 * @property {string | null} notes
 * @property {string} createdAt   ISO 8601 timestamp
 * @property {string} updatedAt   ISO 8601 timestamp
 */

/**
 * @typedef {Object} BookingItemInsertParams
 * @property {string} id
 * @property {string} bookingId
 * @property {("FLIGHT"|"HOTEL"|"CAR")} itemType
 * @property {string | null} [flightId]
 * @property {string | null} [hotelId]
 * @property {string | null} [carId]
 * @property {string | null} [startDate]   ISO `YYYY-MM-DD` or null
 * @property {string | null} [endDate]     ISO `YYYY-MM-DD` or null
 * @property {number} quantity
 * @property {number} unitPrice
 * @property {number} totalPrice
 * @property {string} currency
 * @property {Record<string, any> | null} [metadata]
 */

/**
 * @typedef {Object} BookingItemRecord
 * @property {string} id
 * @property {string} bookingId
 * @property {("FLIGHT"|"HOTEL"|"CAR")} itemType
 * @property {string | null} flightId
 * @property {string | null} hotelId
 * @property {string | null} carId
 * @property {string | null} startDate
 * @property {string | null} endDate
 * @property {number} quantity
 * @property {number} unitPrice
 * @property {number} totalPrice
 * @property {string} currency
 * @property {Record<string, any> | null} metadata
 * @property {string} createdAt
 * @property {string} updatedAt
 */

/**
 * Internal helper to normalize a DATE (or string) to `YYYY-MM-DD` or null.
 *
 * @param {Date | string | null | undefined} value
 * @returns {string | null}
 */
function normalizeDateOnly(value) {
    if (!value) return null;

    if (value instanceof Date) {
        // MySQL DATE comes through as Date (midnight) or string; slice only date part.
        return value.toISOString().slice(0, 10);
    }

    // Assume value is already YYYY-MM-DD or includes a date prefix.
    return String(value).slice(0, 10);
}

/**
 * Retrieve bookings for a user filtered by scope and reference time.
 *
 * @param {string} userId
 * @param {{ scope: "past"|"current"|"future"|"all", now: Date }} options
 * @returns {Promise<BookingRecord[]>}
 */
export async function getUserBookingsByScope(userId, { scope, now }) {
  // Implement SQL query using your MySQL pool/knex:
  // - Use `scope` and `now` to filter on start_date/end_date columns.
  // - Join booking_items if you want item-level detail.
}


/**
 * Internal helper to normalize a DATETIME (or string) to ISO 8601.
 *
 * @param {Date | string | null | undefined} value
 * @returns {string}
 */
function normalizeDateTime(value) {
    if (!value) return new Date(0).toISOString();

    if (value instanceof Date) {
        return value.toISOString();
    }

    const parsed = new Date(value);
    if (Number.isNaN(parsed.getTime())) {
        // Fallback to current time if something bizarre comes back from the driver.
        return new Date().toISOString();
    }
    return parsed.toISOString();
}

/**
 * Map a raw MySQL row from `bookings` into a BookingRecord.
 *
 * @param {any} row
 * @returns {BookingRecord}
 */
function mapBookingRow(row) {
    return {
        id: row.id,
        userId: row.user_id,
        bookingReference: row.booking_reference,
        status: row.status,
        totalAmount: Number(row.total_amount),
        currency: row.currency,
        startDate: normalizeDateOnly(row.start_date),
        endDate: normalizeDateOnly(row.end_date),
        notes: row.notes ?? null,
        createdAt: normalizeDateTime(row.created_at),
        updatedAt: normalizeDateTime(row.updated_at)
    };
}

/**
 * Map a raw MySQL row from `booking_items` into a BookingItemRecord.
 *
 * @param {any} row
 * @returns {BookingItemRecord}
 */
function mapBookingItemRow(row) {
    let metadata = row.metadata ?? null;

    // MySQL JSON columns may be returned as strings in some configurations.
    if (typeof metadata === "string") {
        try {
            metadata = JSON.parse(metadata);
        } catch {
            // Leave as raw string if parsing fails.
        }
    }

    return {
        id: row.id,
        bookingId: row.booking_id,
        itemType: row.item_type,
        flightId: row.flight_id ?? null,
        hotelId: row.hotel_id ?? null,
        carId: row.car_id ?? null,
        startDate: normalizeDateOnly(row.start_date),
        endDate: normalizeDateOnly(row.end_date),
        quantity: Number(row.quantity),
        unitPrice: Number(row.unit_price),
        totalPrice: Number(row.total_price),
        currency: row.currency,
        metadata: metadata ?? null,
        createdAt: normalizeDateTime(row.created_at),
        updatedAt: normalizeDateTime(row.updated_at)
    };
}

/**
 * Insert a new booking header row.
 *
 * @param {BookingInsertParams} booking
 * @param {import("mysql2/promise").PoolConnection | null} [connection]
 * @returns {Promise<BookingRecord>}
 */
export async function insertBooking(booking, connection = null) {
    const sql = `
    INSERT INTO bookings (
      id,
      user_id,
      booking_reference,
      status,
      total_amount,
      currency,
      start_date,
      end_date,
      notes
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
  `;

    const params = [
        booking.id,
        booking.userId,
        booking.bookingReference,
        booking.status,
        booking.totalAmount,
        booking.currency,
        booking.startDate,
        booking.endDate,
        booking.notes ?? null
    ];

    // INSERT result is not used directly; we re-fetch the row for a normalized record.
    await mysqlQuery(sql, params, connection);
    const found = await findBookingById(booking.id, connection);

    // Given we just inserted, the record should exist; but guard just in case.
    if (!found) {
        throw new Error(
            `[bookings-repository] Failed to re-fetch booking after insert (id=${booking.id}).`
        );
    }

    return found;
}

/**
 * Insert a booking line item row.
 *
 * @param {BookingItemInsertParams} item
 * @param {import("mysql2/promise").PoolConnection | null} [connection]
 * @returns {Promise<BookingItemRecord>}
 */
export async function insertBookingItem(item, connection = null) {
    const sql = `
    INSERT INTO booking_items (
      id,
      booking_id,
      item_type,
      flight_id,
      hotel_id,
      car_id,
      start_date,
      end_date,
      quantity,
      unit_price,
      total_price,
      currency,
      metadata
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `;

    const params = [
        item.id,
        item.bookingId,
        item.itemType,
        item.flightId ?? null,
        item.hotelId ?? null,
        item.carId ?? null,
        item.startDate,
        item.endDate,
        item.quantity,
        item.unitPrice,
        item.totalPrice,
        item.currency,
        item.metadata ? JSON.stringify(item.metadata) : null
    ];

    await mysqlQuery(sql, params, connection);
    const found = await findBookingItemById(item.id, connection);

    if (!found) {
        throw new Error(
            `[bookings-repository] Failed to re-fetch booking item after insert (id=${item.id}).`
        );
    }

    return found;
}

/**
 * Find a booking header by primary key.
 *
 * @param {string} bookingId
 * @param {import("mysql2/promise").PoolConnection | null} [connection]
 * @returns {Promise<BookingRecord | null>}
 */
export async function findBookingById(bookingId, connection = null) {
    const sql = `
    SELECT *
    FROM bookings
    WHERE id = ?
    LIMIT 1
  `;

    const rows = await mysqlQuery(sql, [bookingId], connection);
    if (!rows || rows.length === 0) {
        return null;
    }

    return mapBookingRow(rows[0]);
}

/**
 * Find a booking item by primary key.
 *
 * @param {string} itemId
 * @param {import("mysql2/promise").PoolConnection | null} [connection]
 * @returns {Promise<BookingItemRecord | null>}
 */
export async function findBookingItemById(itemId, connection = null) {
    const sql = `
    SELECT *
    FROM booking_items
    WHERE id = ?
    LIMIT 1
  `;

    const rows = await mysqlQuery(sql, [itemId], connection);
    if (!rows || rows.length === 0) {
        return null;
    }

    return mapBookingItemRow(rows[0]);
}

/**
 * Fetch a booking header and all of its items in a single helper call.
 *
 * @param {string} bookingId
 * @param {import("mysql2/promise").PoolConnection | null} [connection]
 * @returns {Promise<{ booking: BookingRecord, items: BookingItemRecord[] } | null>}
 */
export async function findBookingWithItemsById(bookingId, connection = null) {
    const booking = await findBookingById(bookingId, connection);
    if (!booking) {
        return null;
    }

    const sqlItems = `
    SELECT *
    FROM booking_items
    WHERE booking_id = ?
    ORDER BY created_at ASC
  `;

    const itemRows = await mysqlQuery(sqlItems, [bookingId], connection);
    const items = (itemRows || []).map(mapBookingItemRow);

    return { booking, items };
}

/**
 * Update the status (and optionally start/end dates & totals) of a booking.
 *
 * This helper is intentionally conservative: callers are expected to compute
 * totals and date ranges before calling.
 *
 * @param {string} bookingId
 * @param {BookingStatus} status
 * @param {{ totalAmount?: number, startDate?: string | null, endDate?: string | null } | undefined} [patch]
 * @param {import("mysql2/promise").PoolConnection | null} [connection]
 * @returns {Promise<BookingRecord | null>}
 */
export async function updateBookingStatus(
    bookingId,
    status,
    patch = undefined,
    connection = null
) {
    const fields = ["status = ?"];
    /** @type {any[]} */
    const params = [status];

    if (patch && typeof patch.totalAmount === "number") {
        fields.push("total_amount = ?");
        params.push(patch.totalAmount);
    }

    if (patch && "startDate" in patch) {
        fields.push("start_date = ?");
        params.push(patch.startDate ?? null);
    }

    if (patch && "endDate" in patch) {
        fields.push("end_date = ?");
        params.push(patch.endDate ?? null);
    }

    params.push(bookingId);

    const sql = `
    UPDATE bookings
    SET ${fields.join(", ")}
    WHERE id = ?
  `;

    await mysqlQuery(sql, params, connection);
    return findBookingById(bookingId, connection);
}

/**
 * List bookings for a given user, optionally filtered by a date scope.
 *
 * Scope semantics:
 * - "past":    end_date < today
 * - "current": start_date <= today AND end_date >= today
 * - "future":  start_date > today
 * - undefined/null: all bookings
 *
 * @param {string} userId
 * @param {("past"|"current"|"future"|null)} [scope]
 * @param {string | null} [todayOverride] Optional ISO date `YYYY-MM-DD` for testing.
 * @param {import("mysql2/promise").PoolConnection | null} [connection]
 * @returns {Promise<BookingRecord[]>}
 */
export async function listBookingsForUser(
    userId,
    scope = null,
    todayOverride = null,
    connection = null
) {
    let sql = `
    SELECT *
    FROM bookings
    WHERE user_id = ?
  `;
    /** @type {any[]} */
    const params = [userId];

    const today =
        todayOverride ||
        new Date().toISOString().slice(0, 10); // YYYY-MM-DD

    if (scope === "past") {
        sql += " AND end_date IS NOT NULL AND end_date < ?";
        params.push(today);
    } else if (scope === "current") {
        sql +=
            " AND start_date IS NOT NULL AND end_date IS NOT NULL AND start_date <= ? AND end_date >= ?";
        params.push(today, today);
    } else if (scope === "future") {
        sql += " AND start_date IS NOT NULL AND start_date > ?";
        params.push(today);
    }

    sql += " ORDER BY created_at DESC";

    const rows = await mysqlQuery(sql, params, connection);
    return (rows || []).map(mapBookingRow);
}
